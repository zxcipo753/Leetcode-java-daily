/*思维方式：

想象一下你正在玩一个游戏。你有一个目标字符串和一些“积木”（这些积木就是 wordDict 中的单词）。你需要看看是否可以使用这些积木（可以重复使用）组合成目标字符串。

例如：目标字符串是 "applepenapple", 积木是 ["apple","pen"]。你可以先使用 "apple" 积木，然后使用 "pen" 积木，最后再次使用 "apple" 积木来组合成目标字符串。

解题步骤:

初始化一个标记数组：创建一个布尔数组 dp，长度为字符串长度 + 1。其中，dp[i] 表示字符串 s 的前 i 个字符是否可以被 wordDict 分割。例如，如果 dp[4] 为真，那么 s 的前四个字符可以用 wordDict 中的词来分割。

开始构建：首先，dp[0] 是 true，因为一个空字符串总是可以被表示的（没有使用任何积木）。

双层循环：外循环遍历字符串 s，内循环遍历 wordDict。

对于每个 i（代表 s 的长度），我们查看所有的 word 是否为有效的后缀。如果它是，并且剩余的部分（即 s 的前面部分）可以被 wordDict 分割（这是通过检查 dp 的相应部分来确定的），那么 dp[i] 就可以被设置为 true。
返回结果：在循环结束后，dp[s.length()] 将给出答案。如果 s 可以完全由 wordDict 分割，则返回 true，否则返回 false。

这就是动态规划的魅力！你从一个小问题开始（如何组合一个很短的字符串），然后基于这个答案来解决更大的问题，直到得到最终答案。希望这个解释对你有帮助！*/
